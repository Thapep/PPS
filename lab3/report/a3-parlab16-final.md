<h3 style="text-align:center">Εθνικό Μετσόβιο Πολυτεχνείο</h3>

<h3 style="text-align:center">Συστήματα Παραλλήλης Επεξεργασίας</h3>





<h4 style="text-align:center">Εργαστηριακή άσκηση 3</h4>

<h4 style='text-align:center;'>Θέματα Συγχρονισμού σε Σύγχρονα Πολυπύρηνα Συστήματα</h4>



***1. Σκοπός της άσκησης***

Σκοπός της συγκεκριμένης άσκησης είναι η εξοικείωση με την εκτέλεση προγραμμάτων σε σύγχρονα πολυπύρηνα συστήματα και η αξιολόγηση της επίδοσής τους. Συγκεκριμένα, θα εξετάσετε πώς κάποια χαρακτηριστικά της αρχιτεκτονικής του συστήματος επηρεάζουν την επίδοση των εφαρμογών που εκτελούνται σε αυτά και θα αξιολογήσετε διάφορους τρόπους υλοποίησης κλειδωμάτων για αμοιβαίο αποκλεισμό καθώς και διάφορες τακτικές συγχρονισμού για δομές δεδομένων.



***2. Λογαριασμοί Τράπεζας***

Στο πρώτο μέρος της άσκησης μας δίνεται ένα πολυνηματικό πρόγραμμα όπου κάθε νήμα εκτελεί ένα σύνολο πράξεων πάνω σε συγκεκριμένο στοιχείο ενός πίνακα που αντιπροσωπεύει τους λογαριασμούς των πελατών μίας τράπεζας.



***2.1. Υπάρχει ανάγκη για συγχρονισμό ανάμεσα στα νήματα της εφαρμογής;***

Κάθε νήμα εκτελεί πράξεις πάνω σε διαφορετικά δεδομένα συνεπώς δε χρειάζεται να τα συγχρονίσουμε.



***2.2. Πώς περιμένετε να μεταβάλλεται η επίδοση της εφαρμογής καθώς αυξάνετε τον αριθμό των
νημάτων;***

Από τη στιγμή που δεν υπάρχει θέμα συγχρονισμού αναμένουμε η επίδοση να αυξάνει ανάλογα με την αύξηση των νημάτων. 



***2.3. Εκτελέστε την εφαρμογή με 1,2,4,8,16,32,64 νήματα χρησιμοποιώντας τις τιμές για την MT_CONF που δίνονται στον πίνακα 1. Δώστε ένα διάγραμμα όπου στον άξονα x θα είναι ο αριθμός των νημάτων και στον άξονα y το αντίστοιχο throughput. Το διάγραμμα θα περιέχει δύο καμπύλες, μία για κάθε εκτέλεση του πίνακα 1. Ποια είναι η συμπεριφορά της εφαρμογής για κάθε μία από τις δύο εκτελέσεις; Εξηγήστε αυτήν την συμπεριφορά και τις διαφορές ανάμεσα στις δύο εκτελέσεις.***



Εκτελούμε το πρόγραμμα `accounts` με βάση τον παρακάτω πίνακα

| Αριθμός Νημάτων | Εκτέλεση 1 |      Εκτέλεση 2      |
| :-------------: | :--------: | :------------------: |
|        1        |     0      |          0           |
|        2        |    0,1     |         0,8          |
|        4        |    0-3     |      0,8,16,32       |
|        8        |    0-7     | 0-1,8-9,16-17,24-25  |
|       16        | 0-7,32-39  | 0-3,8-11,16-19,24-27 |
|       32        | 0-15,32-47 |         0-31         |
|       64        |    0-63    |         0-63         |



Ύστερα από την εκτέλεση του προγράμματος έχουμε τα εξής αποτελέσματα

![throughput_bank](/home/peptop/Documents/PPS/lab3/plots/throughput_bank.png)



Παρατηρούμε ότι, σε αντίθεση με αυτό που περιμέναμε, η επίδοση της εφαρμογής μειώνεται καθώς προσθέτουμε νέους πυρήνες. Για να ερμηνεύσουμε τώρα την συμπεριφορά των δύο καμπυλών, πρέπει πρώτα να μελετήσουμε την αρχιτεκτονική του μηχανήματος sandman στο οποίο εκτελείται.

![image-20210110150824564](/home/peptop/snap/typora/33/.config/Typora/typora-user-images/image-20210110150824564.png)



Από τις παραπάνω εικόνες, αυτό που πρέπει να παρατηρήσουμε είναι ότι:

* Τα ζευγάρια 0-32, 1-33, ..., 31-63 τρέχουν στον ίδιο πυρήνα και συνεπώς μοίραζονται όλα τα στάδια της ιεραρχίας μνήμης (Hyperthreading).
*  Τα νήματα 0-7, 32-39 βρίσκονται στον ίδιο κόμβο (node 0) και μοιράζονται την L3 cache
  (αντίστοιχα και για τα υπόλοιπα nodes).

Παρατηρούμε ότι στην 1η εκτέλεση, χρησιμοποιούνται πυρήνες όσο πιο κοντά γίνεται ώστε να μοιράζονται κάποια κομμάτια της ιεραρχίας μνήμης και η μεταφορά ενός block από την cache του ενός στην cache του άλλου να είναι η ελάχιστη. Από την άλλη πλευρά, στην 2η εκτέλεση, ο χρόνος αυτός μεγιστοποιείται εκτελώντας τις λειτουργίες σε όσο γίνεται πιο μακρινούς πυρήνες. Το ερώτημα τώρα είναι γιατί έχουμε συνεχή μεταφορά δεδομένων αφού οι λειτουργίες των νημάτων είναι ξεχωριστές. Στο πρόγραμμα μας, έχουμε τον πίνακα accounts ο οποίος έχει τόσες θέσεις όσα και τα νήματα και κάθε θέση του είναι ενας μη προσημασμένος ακέραιος, δηλαδή 4 bytes. Από την στιγμή που οι πίνακες αποθηκεύονται σε συνεχόμενες θέσεις μνήμης, ο πίνακας αυτός έχει μέγεθος threads*4 συνεχόμενες θέσεις. Ο λόγος που το πρόγραμμά μας δεν κλιμακώνει είναι ότι το μέγεθος block της cache είναι μεγαλύτερο από το μέγεθος μιας θέσης του πίνακα. Συνεπώς, όταν ένα νήμα διαβάζει και γράφει σε μία θέση, φέρνει αυτό το block στην cache του και από την στιγμή που αυτό το block το είχε γράψει και κάποιο άλλο νήμα, το τρέχον νήμα πρέπει να ενημερώσει την cache του, σύμφωνα με τα γνωστό πρωτόκολλα (MESI). Συνεπώς, παρά το γεγονός ότι τα νήματα διαβάζουν και γράφουν σε διαφορετικές θέσεις μνήμης, καθυστερούν το ένα την εκτέλεση του άλλου επειδή αυτές οι θέσεις βρίσκονται στο ίδιο block της cache. Έτσι, έχουμε μία συνεχή μεταφορά δεδομένων μεταξύ των cache των πυρήνων, με αποτέλεσμα στην 2η εκτέλεση όπου οι πυρήνες είναι στις χειρότερες δυνατές θέσεις, να προκαλείται η μεγαλύτερη δυνατή καθυστέρηση για την ενημέρωση των επιπέδων της ιεραρχίας της μνήμης.



***4. Η εφαρμογή έχει την συμπεριφορά που αναμένατε; Αν όχι, εξηγήστε γιατί συμβαίνει αυτό και
προτείνετε μία λύση. Τροποποιήστε κατάλληλα τον κώδικα και δώστε και πάλι τα αντίστοιχα διαγράμματα για τις δύο εκτελέσεις. Υπόδειξη: πώς αποθηκεύεται ο πίνακας με τους λογαριασμούς στα διάφορα επίπεδα της ιεραρχίας της μνήμης και τι προκαλεί αυτό ανάμεσα στα νήματα της εφαρμογής;***



Για να μπερέσουμε να αξιοποιήσουμε καλύτερα τις cache μπορούμε να βάλουμε ενα padding στα δεδομένα ώστε  κάθε νήμα να εκτελεί σε διαφορετικό block και να μην υπάρχει αληλλεπίδραση μεταξύ των νημάτων. 

Παρακάτω φαίνεται ο τροποποιημένος κώδικας

```c
/**
 * The accounts’ array.
 **/
struct {
unsigned int value;
	char padding_acc[64−sizeof(unsigned int)];
} accounts[MAX_THREADS];
```



Τώρα τα αποτελέσματα που παίρνουμε από τις δύο εκτελέσεις είναι τα εξής

![throughput_bank_opt](/home/peptop/Documents/PPS/lab3/plots/throughput_bank_opt.png)



Παρατηρούμε το πρόγραμμα τώρα κλιμακώνει πολύ καλά. Επίσης, παρατηρούμε ότι η 2η εκτέλεση είναι αποδοτικότερη από την 1η για 16 και 32 νήματα. Αυτό συμβαίνει διότι στην 1η περίπτωση έχουμε 16 (και 32) νήματα να τρέχουν σε 8 (και 16) πυρήνες, έχουμε, δηλαδή, συνεχώς δύο νήματα ενεργά ανά πυρήνα. Αντίθετα, στην 2η περίπτωση για 16 (και 32) νήματα χρησιμοποιούμε 16 (και 32) πυρήνες, ένα για κάθε νήμα, με αποτέλεσμα να μην παρεμβάλλονται εντολές από 2 νήματα σε ένα πυρήνα. Ουσιαστικά, εδώ όπου όλες οι λειτουργίες είναι ανεξάρτητες και θα μπορούσαν να εκτελεστούν εντελώς παράλληλα, το hyperthreading προκαλεί καθυστερήσεις.